// PartTool - replacement for GetPartns and ReadPart.
// Copyright (C) 1998-2004 Phil Norman and Marco Baye
//
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
//
// This was derived from Phil Norman's "GetPartns" program, which reads the
// linux partition on a given disc and creates IscaFS pseudo image files for
// each ext2 partition found.
//
// 22/23 Apr 2004
//	Attempted to make it a tiny bit nicer - now it needs OSLib, though ;)
//	Renamed to PartTool. Now has three uses:
//	*parttool display <fs> <drive>
//		show partition info
//	*parttool makepseudo <fs> <drive> <partition> <file>
//		creates IscaFS pseudo image file
//	*parttool dumptofile <fs> <drive> <partition> <file>
//		dumps whole partition to file (if partition is < 4GB)
//
// let's call it version 0.02
// TODO: add "--mbr" option to use pc-style partition table instead of ARMLinux one


#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "oslib/os.h"
#include "oslib/osfile.h"
#include "oslib/osfind.h"
#include "oslib/osgbpb.h"
#include "oslib/osmodule.h"
#include "oslib/filecore.h"


// largest sector size this program supports:
#define MAX_SECTOR_SIZE		4096

// FileCore's "non-ADFS partition descriptor" types:
//#define NONFILECORE_RISCIX			1	// RISC iX partition
#define NONFILECORE_ARMLINUXPARTITIONTABLE	9	// partition table for ARMLinux
// entries in ARMLinux partition table (located after FileCore part):
struct linux_part {
	int	magic;	// what the partition contains (see below)
	int	rel_start_sector;	// CAUTION, relative to sector of partition table!
	int	sector_count;
};
// partition types:
#define MAGIC_NATIVE	0xdeafa1de	// likely ext2/3/4
#define MAGIC_SWAP	0xdeafab1e

// how this program passes partition data around:
struct partition {
	int		start_sector;	// absolute
	int		sector_count;
	const char	*type_string;	// "Native", "Swap", "Other", "Unknown" etc.
	bool		is_linux_native;	// likely ext2/3/4
};

// chunk size when dumping a partition to a file:
#define SECTORS_PER_CHUNK	1024	// 512K if 512 byte per sector

// types for generated files:
#define FILETYPE_ISCAFS	0x0b0	// "ext2fs" (not registered)
#define FILETYPE_OTHER	0xffd	// "Data"

// command strings:
//#define COMMAND_HEX		"hex"	FIXME - add!
#define COMMAND_DISPLAY		"display"
#define COMMAND_MKPSEUDO	"makepseudo"
#define COMMAND_DUMP		"dumptofile"

// globals
struct {
	char		*prog_name;
	void		*private_word;
	int		partition_sector;	// sector holding ARMLinux partition table
} globals;

struct {
	const char	*filing_system_name;
	int		drive_number;
	int		desired_partition;
	const char	*output_file_name;
} args;

// sector buffers
byte	first4K[MAX_SECTOR_SIZE];
byte	partitiontable[MAX_SECTOR_SIZE];

filecore_disc	discrecord;

// error handler
static void exit_error(const char msg[], bool show_syntax)
{
	if (msg)
		fprintf(stderr, "\nError: %s\n", msg);
	if (show_syntax)
		fprintf(stderr,
"\n"
"Syntax:\n"
"    %s "COMMAND_DISPLAY" <filing_system> <drive>\n"
"        ...displays partition info\n"
"    %s "COMMAND_MKPSEUDO" <filing_system> <drive> <partition_id> <filename>\n"
"        ...creates a pseudo image file for IscaFS\n"
"    %s "COMMAND_DUMP" <filing_system> <drive> <partition_id> <filename>\n"
"        ...dumps whole partition to file (only if partition size < 4GB)\n",
			globals.prog_name, globals.prog_name, globals.prog_name);

	exit(EXIT_FAILURE);
}


// catch os errors and send to program's error handler
static void oslibwrapper(os_error *err)
{
	if (err)
		exit_error(err->errmess, FALSE);
}


// read sectors using the old (29-bit) interface
static void readsectors_via_29bit_filecore(int start_sector, char *buf, int bufsize)
{
	filecorediscop_read_sectors(
		((int) &discrecord) << 6,
		(start_sector << discrecord.log2secsize) | (args.drive_number << 29),
		buf, bufsize, &globals.private_word, NULL, NULL);
	// TODO: check return value (number of bytes unread)
}


// read sectors using the newer (38-bit) interface
static void readsectors_via_38bit_filecore(int start_sector, char *buf, int bufsize)
{
	filecoresectorop_read_sectors(
		((int) &discrecord) << 6,
		start_sector | (args.drive_number << 29),
		buf, bufsize, &globals.private_word, NULL, NULL);
	// TODO: check return value (number of bytes unread)
}


// read sectors using the newest (64-bit) interface
// FIXME - add code for filecorediscop64_read_sectors() call!


// function pointer for reading sectors
// initially, the old (29-bit) FileCore_DiscOp interface is used. It is then
// changed to use the newer (38-bit) FileCore_SectorOp, if available.
static void	(*read_sectors)(int start_sector, char *buf, int bufsize)	= readsectors_via_29bit_filecore;


// set drive size so FileCore won't refuse to access beyond FileCore partition
static void set_sector_limit(unsigned int sector_limit)
{
	discrecord.disc_size = sector_limit << discrecord.log2secsize;
	discrecord.disc_size_hi = sector_limit >> (32 - discrecord.log2secsize);
	if (read_sectors == readsectors_via_38bit_filecore)
		return;

	// check for old FileCore limit
	if ((discrecord.disc_size_hi) || (discrecord.disc_size >> 29))
		exit_error("Sorry, your version of FileCore cannot read this far into the disc.", FALSE);
}


// helper function to output human-readable disc size
const char *units[]	= {
		//  leading	bits	bits
		//  zeroes	shown	ignored
	"Byte",	//	52	12
	"KiB",	//	42	12	10
	"MiB",	//	32	12	20
	"GiB",	//	22	12	30
	"TiB",	//	12	12	40
	"PiB",	//	 2	12	50
	"EiB"	//		 4	60
};
static void print_size(unsigned long long number)
{
	int	unit	= 0;

	while (number > 4095) {
		number >>= 10;
		++unit;
	}
	printf("%d %s", (int) number, units[unit]);
}


// common start for all three operations
static void common_start(int argc, char *argv[], int desired_argc)
{
	char	module_title[256];	// buffer for "FileCore%FILINGSYSTEM"
	char	disc_spec[16];		// holds ":DRIVENUMBER" string

	if (argc != desired_argc)
		exit_error("Wrong number of arguments", TRUE);

	// remember name of filing system
	args.filing_system_name = argv[0];

	// build module title
	sprintf(module_title, "FileCore%%%s", args.filing_system_name);

	// get module's private word
	if (xosmodule_lookup(module_title, NULL, NULL, NULL, &globals.private_word, NULL))
		exit_error("Given filing system does not exist or is not a FileCore filing system", TRUE);

	// get drive number
	if (sscanf(argv[1], "%d", &args.drive_number) != 1)
		exit_error("Could not parse drive number", TRUE);

	// FIXME - check whether 64-bit access is available!

	// check whether 38-bit FileCore is available
	// if yes, use it
	if (!xos_swi_number_from_string("FileCore_SectorOp", NULL))
		read_sectors = readsectors_via_38bit_filecore;

	// examine disc
	sprintf(disc_spec, ":%d", args.drive_number);
	oslibwrapper(xfilecore_describe_disc(disc_spec, &discrecord, &globals.private_word));
	// display important data:
	// output some data, like sector size and maybe cylinders, heads and sectors
	printf("DEBUG: Sector size:\t\t%d (log2=%d)\n", 1u << discrecord.log2secsize, discrecord.log2secsize);
	printf("DEBUG: Heads:\t\t\t%d\n", discrecord.heads);
	printf("DEBUG: Sectors per track:\t%d\n", discrecord.secspertrack);
// if heads and sectors are 1 and 1, fake to 16 and 63:
// FIXME - does not change anything unless FileCore is told about it!
//	if ((discrecord.heads == 1) && (discrecord.secspertrack == 1)) {
//		discrecord.heads = 16;
//		discrecord.secspertrack = 63;
//	}
	printf("DEBUG: Disc size:\t\t");
	print_size((((unsigned long long) discrecord.disc_size_hi) << 32) | discrecord.disc_size);
	printf("\n");

	// Read boot block. Actually it's located at byte offset &0c00, but
	// we're using sector addressing, so we're reading 4096 bytes starting
	// from sector 0 to make sure this works with all sector sizes:
	read_sectors(0, first4K, MAX_SECTOR_SIZE);

// FIXME - add support for PC/BIOS partitioning scheme!
// all this is only for FileCore/ARMLinux partitioning scheme:
	if (first4K[0xdfc] != NONFILECORE_ARMLINUXPARTITIONTABLE)
		exit_error("Second partition is not a linux partition table", FALSE);

	globals.partition_sector = discrecord.secspertrack * discrecord.heads * ((first4K[0xdfd]) + ((first4K[0xdfe]) << 8));

	// set disc size so FileCore won't refuse to access partition table
	set_sector_limit(globals.partition_sector + 2);	// !PartMan assigns 2 blocks of 512 bytes

	// read partition table
	read_sectors(globals.partition_sector, partitiontable, 1024);
}


// loop over partitions, calling given callback function for each (unless NULL)
// returns whether wanted partition data has been copied to struct (unless NULL)
static bool process_all_partitions(struct linux_part *part, void (*callback)(int id, struct partition *part), struct partition *wanted_part)
{
	struct partition	current;
	bool			found	= FALSE;
	int			partition_id;

	partition_id = 3;	// 1 = FileCore, 2 = Linux partition table
	while ((part->magic == MAGIC_NATIVE) || (part->magic == MAGIC_SWAP)) {
		// convert entry to our own format
		current.start_sector = globals.partition_sector + part->rel_start_sector;	// convert relative to absolute number
		current.sector_count = part->sector_count;
		current.type_string = (part->magic == MAGIC_NATIVE) ? "Native" : "Swap";
		current.is_linux_native = (part->magic == MAGIC_NATIVE);
		// pass to callback
		if (callback)
			callback(partition_id, &current);
		// remember for caller
		if (wanted_part && (partition_id == args.desired_partition)) {
			*wanted_part = current;
			found = TRUE;
		}
		++partition_id;
		++part;
	}
	return found;
}


// display partition info
static void displayinfo(int id, struct partition *part)
{
	static bool	show_header	= TRUE;

	if (show_header) {
		printf(" ID   Start sector    Sectors  Type\n");
		show_header = FALSE;
	}
	printf("%3d    %10d  %10d  %s\n", id, part->start_sector, part->sector_count, part->type_string);
}


//
static void main_display_info(int argc, char *argv[])
{
	common_start(argc, argv, 2);
	process_all_partitions((struct linux_part *) partitiontable, displayinfo, NULL);
}


// handle additional arguments (partition number and output filename)
static void get_extended_arguments(char *argv[])
{
	if (sscanf(argv[0], "%d", &args.desired_partition) != 1)
		exit_error("Could not parse partition number", TRUE);
	args.output_file_name = argv[1];
}


static void done(const char *filedescription)
{
	printf(
"Done.\n"
"If you have IscaFS, double-clicking the %s should open it.\n"
"That is, if the partition contains a valid ext2/ext3 filesystem.\n"
	, filedescription);
}


// file format of pseudo image files
struct pseudo_image_file {
	bits	Phil;		// magic word to recognize file format
	bits	ext2;		// magic word to recognize contents
	int	first_sector;	// first sector of partition
	int	last_sector;	// last sector of partition
	int	log2secsize;	// log2 of sector size
	int	drive;		// drive number
	char	fs[256];	// filing system, nullterminated
};
// generate a pseudo image file
static void main_make_pseudo(int argc, char *argv[])
{
	struct partition		part;
	struct pseudo_image_file	pif;
	int				string_length;

	common_start(argc, argv, 4);
	get_extended_arguments(argv + 2);

	// build pseudo image file in memory
	string_length = strlen(args.filing_system_name) + 1;
	if (string_length > 256)
		exit_error("Length of filing system name looks a bit excessive.", FALSE);

	if (process_all_partitions((struct linux_part *) partitiontable, NULL, &part) == FALSE)
		return;	// number not found

	if (!part.is_linux_native) {
		fprintf(stderr, "Partition %d is not a Linux Native partition.\n", args.desired_partition);
		return;
	}

	displayinfo(args.desired_partition, &part);

	// fill in the struct
	pif.Phil = 0x4cee68fe;	// "þhîL"       (comment string is UTF-8!)
	pif.ext2 = 0x32747865;	// "ext2"
	pif.first_sector = part.start_sector;
	pif.last_sector = pif.first_sector + part.sector_count - 1;
	pif.log2secsize = discrecord.log2secsize;
	pif.drive = args.drive_number;
	strcpy(pif.fs, args.filing_system_name);

	oslibwrapper(xosfile_save_stamped(
		args.output_file_name,
		FILETYPE_ISCAFS,
		(byte *) &pif,
		((byte *) &pif) + 24 + string_length));	// 24 is length of header before string...

	done("pseudo image file");
}


// dump partition to file
static void main_dump_to_file(int argc, char *argv[])
{
	struct partition	part;
	unsigned int		startsector,
				bytes_per_chunk,
				bytes_to_transfer;
	os_fw			file_handle;
	os_error		*err		= NULL;
	char			*chunk;
	int			unwritten	= 0;

	common_start(argc, argv, 4);
	get_extended_arguments(argv + 2);

	if (process_all_partitions((struct linux_part *) partitiontable, NULL, &part) == FALSE)
		return;	// not found

	displayinfo(args.desired_partition, &part);

	// check hypothetical size of output file
	if (part.sector_count >= (0xffffffffu >> discrecord.log2secsize))
		exit_error("Dump file would exceed the 4 GB file size limit imposed by RISC OS", FALSE);

	// calculate transfer values
	startsector = part.start_sector;
	bytes_per_chunk = SECTORS_PER_CHUNK << discrecord.log2secsize;
	bytes_to_transfer = part.sector_count << discrecord.log2secsize;

	// set new disc size so FileCore won't refuse to access partition
	set_sector_limit(startsector + part.sector_count);

	// calculate transfer values: buffer size, transfer count
	chunk = (char *) malloc(bytes_per_chunk);
	if (chunk == NULL)
		exit_error("Could not allocate transfer buffer", FALSE);

	// try to create file with needed size
	oslibwrapper(xosfile_create_stamped(
		args.output_file_name,
		part.is_linux_native ? FILETYPE_ISCAFS : FILETYPE_OTHER,
		bytes_to_transfer));

	// open file
	oslibwrapper(xosfind_openupw(
		osfind_NO_PATH | osfind_ERROR_IF_ABSENT | osfind_ERROR_IF_DIR,
		args.output_file_name,
		NULL,
		&file_handle));

	puts("Transfer in progress");

	// transfer loop
	while (bytes_to_transfer > bytes_per_chunk) {
		read_sectors(startsector, chunk, bytes_per_chunk);
		err = xosgbpb_writew(file_handle, chunk, bytes_per_chunk, &unwritten);
		if (err || unwritten)
			break;

		startsector += SECTORS_PER_CHUNK;
		bytes_to_transfer -= bytes_per_chunk;
		putchar('.');
	}
	if ((err == NULL) && (unwritten == 0)) {
		read_sectors(startsector, chunk, bytes_to_transfer);
		err = xosgbpb_writew(file_handle, chunk, bytes_to_transfer, &unwritten);
		putchar('.');
	}

	// close file
	xosfind_closew(file_handle);	// ignore errors

	if (err)
		oslibwrapper(err);
	if (unwritten)
		exit_error("Could not write all bytes", FALSE);

	//
	if (part.is_linux_native)
		done("image file");
	else
		printf("Done.\n");
}


//
int main(int argc, char *argv[])
{
	// first thing to do, as it's needed by the error handler
	globals.prog_name = argv[0];

	// check number of command line arguments
	if (argc < 2)
		exit_error(NULL, TRUE);

	if (strcmp(argv[1], COMMAND_DISPLAY) == 0)
		main_display_info(argc - 2, argv + 2);
	else if (strcmp(argv[1], COMMAND_MKPSEUDO) == 0)
		main_make_pseudo(argc - 2, argv + 2);
	else if (strcmp(argv[1], COMMAND_DUMP) == 0)
		main_dump_to_file(argc - 2, argv + 2);
	else
		exit_error("Illegal command string", TRUE);

	return EXIT_SUCCESS;
}
