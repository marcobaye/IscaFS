// PartTool - replacement for GetPartns and ReadPart.
// Copyright (C) 1998-2004 Phil Norman and Marco Baye
//
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
//
// This was derived from Phil Norman's "GetPartns" program, which reads the
// linux partition on a given disc and creates IscaFS pseudo image files for
// each ext2 partition found.
//
// 22/23 Apr 2004
//	Attempted to make it a tiny bit nicer - now it needs OSLib, though ;)
//	Renamed to PartTool. Now has three uses:
//	*parttool display <fs> <drive>
//		show partition info
//	*parttool makepseudo <fs> <drive> <partition> <file>
//		creates IscaFS pseudo image file
//	*parttool dumptofile <fs> <drive> <partition> <file>
//		dumps whole partition to file (if partition is < 4GB)
// let's call it version 0.02
//
// TODO: add "--mbr" option to use pc-style partition table instead of ARMLinux one

#define VERSION_STRING	"3"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "oslib/os.h"
#include "oslib/osfile.h"
#include "oslib/osfind.h"
#include "oslib/osgbpb.h"
#include "oslib/osmodule.h"
#include "oslib/filecore.h"


// largest sector size this program supports:
#define MAX_SECTOR_SIZE		4096

// FileCore's "non-ADFS partition descriptor" types:
//#define NONFILECORE_RISCIX			1	// RISC iX partition
#define NONFILECORE_ARMLINUXPARTITIONTABLE	9	// partition table for ARMLinux
// entries in ARMLinux partition table (located after FileCore part):
struct linux_part {
	int	magic;	// what the partition contains (see below)
	int	rel_start_sector;	// CAUTION, relative to sector of partition table!
	int	sector_count;
};
// partition types:
#define MAGIC_NATIVE	0xdeafa1de	// likely ext2/3/4
#define MAGIC_SWAP	0xdeafab1e

// how this program passes partition data around:
struct partition {
	int		start_sector;	// absolute
	int		sector_count;
	const char	*type_string;	// "Native", "Swap", "Other", "Unknown" etc.
	bool		is_linux_native;	// likely ext2/3/4
};

// chunk size when dumping a partition to a file:
#define SECTORS_PER_CHUNK	1024	// 512K if 512 byte per sector

// types for generated files:
#define FILETYPE_ISCAFS	0x0b0	// "ext2fs" (not registered)
#define FILETYPE_OTHER	0xffd	// "Data"

// command strings:
#define OPTION_63_16		"--63-16"
#define OPTION_BIG		"--big"
//#define OPTION_MBR		"--mbr"
#define COMMAND_HEX		"hex"
#define COMMAND_DISPLAY		"display"
#define COMMAND_MKPSEUDO	"makepseudo"
#define COMMAND_DUMPTOFILE	"dumptofile"

// globals
struct {
	char		*prog_name;
	void		*private_word;
	int		partition_sector;	// sector holding ARMLinux partition table
} globals	= { 0 };

struct {
	bool		force_63_16;
	bool		force_big;
	const char	*filing_system_name;
	int		drive_number;
	int		desired_partition;
	const char	*output_file_name;
} args	= { 0 };

// sector buffers
byte	tmp_sector[MAX_SECTOR_SIZE];
byte	partitiontable[MAX_SECTOR_SIZE];

filecore_disc	discrecord;

//
static void show_help(void)
{
	fprintf(stderr,
"\n"
"This is PartTool, version " VERSION_STRING ".\n"
"Syntax:\n"
"    %s [OPTIONS] "COMMAND_HEX" FILING_SYSTEM DRIVE SECTOR_NUMBER\n"
"        ...shows hex dump of sector contents\n"
"    %s [OPTIONS] "COMMAND_DISPLAY" FILING_SYSTEM DRIVE\n"
"        ...displays partition info\n"
"    %s [OPTIONS] "COMMAND_MKPSEUDO" FILING_SYSTEM DRIVE PARTITION_ID OUTPUT_FILENAME\n"
"        ...creates a pseudo image file for IscaFS\n"
"    %s [OPTIONS] "COMMAND_DUMPTOFILE" FILING_SYSTEM DRIVE PARTITION_ID OUTPUT_FILENAME\n"
"        ...dumps whole partition to file (only if partition size < 4GB)\n",
			globals.prog_name, globals.prog_name, globals.prog_name, globals.prog_name);
	printf(
"Options:\n"
"    " OPTION_63_16 "     force 63 sectors per track and 16 heads\n"
"    " OPTION_BIG "       force \"big disc\" flag to 1\n"
	);
}

// error handler
static void exit_error(const char msg[])
{
	if (msg)
		fprintf(stderr, "\nError: %s\n", msg);
	exit(EXIT_FAILURE);
}


// catch os errors and send to program's error handler
static void oslibwrapper(os_error *err)
{
	if (err)
		exit_error(err->errmess);
}


// read sectors using the old (29-bit) interface
static void readsectors_via_29bit_filecore(int start_sector, byte *buf, int bufsize)
{
	filecorediscop_read_sectors(
		((int) &discrecord) << 6,
		(start_sector << discrecord.log2secsize) | (args.drive_number << 29),
		buf, bufsize, &globals.private_word, NULL, NULL);
	// TODO: check return value (number of bytes unread)
}


// read sectors using the newer (38-bit) interface
static void readsectors_via_38bit_filecore(int start_sector, byte *buf, int bufsize)
{
	filecoresectorop_read_sectors(
		((int) &discrecord) << 6,
		start_sector | (args.drive_number << 29),
		buf, bufsize, &globals.private_word, NULL, NULL);
	// TODO: check return value (number of bytes unread)
}

/*
// read sectors using the newest (64-bit) interface
static void readsectors_via_64bit_filecore(int start_sector, byte *buf, int bufsize)
{
	filecore_disc_address64	da64;

	da64.drive = args.drive_number;
	da64.offset_low = start_sector << discrecord.log2secsize;
	da64.offset_high = ((unsigned long long) start_sector) >> (32 - discrecord.log2secsize);

	filecorediscop64_read_sectors(
		((int) &discrecord) << 6,	// FIXME - SWI wants ptr to disc record in r5, so how do I pass it to OSLib?
		&da64,
		buf, bufsize, &globals.private_word, NULL, NULL);
	// TODO: check return value (number of bytes unread)
}
*/

// function pointer for reading sectors
// initially, the old (29-bit) FileCore_DiscOp interface is used. It is then
// changed to use the newer (38-bit) FileCore_SectorOp or the newest (64-bit)
// FileCore_DiscOp64, if available.
static void	(*read_sectors)(int start_sector, byte *buf, int bufsize)	= readsectors_via_29bit_filecore;


// set drive size so FileCore won't refuse to access beyond FileCore partition
static void set_sector_limit(unsigned int sector_limit)
{
	discrecord.disc_size = sector_limit << discrecord.log2secsize;
	discrecord.disc_size_hi = sector_limit >> (32 - discrecord.log2secsize);
	if (read_sectors != readsectors_via_29bit_filecore)
		return;

	// check for old FileCore limit
	if ((discrecord.disc_size_hi) || (discrecord.disc_size >> 29))
		exit_error("Sorry, your version of FileCore cannot read this far into the disc.");
}


// helper function to output human-readable disc size
const char *units[]	= {
		//  leading	bits	bits
		//  zeroes	shown	ignored
	"Byte",	//	52	12
	"KiB",	//	42	12	10
	"MiB",	//	32	12	20
	"GiB",	//	22	12	30
	"TiB",	//	12	12	40
	"PiB",	//	 2	12	50
	"EiB"	//		 4	60
};
static void print_size(unsigned long long number)
{
	int	unit	= 0;

	while (number > 4095) {
		number >>= 10;
		++unit;
	}
	printf("%d %s", (int) number, units[unit]);
}


// common start for all three operations
static void common_start(int argc, char *argv[], int desired_argc)
{
	char	module_title[256];	// buffer for "FileCore%FILINGSYSTEM"
	char	disc_spec[16];		// holds ":DRIVENUMBER" string

	if (argc != desired_argc)
		exit_error("Wrong number of arguments");

	// remember name of filing system
	args.filing_system_name = argv[0];

	// build module title
	sprintf(module_title, "FileCore%%%s", args.filing_system_name);

	// get module's private word
	if (xosmodule_lookup(module_title, NULL, NULL, NULL, &globals.private_word, NULL))
		exit_error("Given filing system does not exist or is not a FileCore filing system");

	// get drive number
	if (sscanf(argv[1], "%d", &args.drive_number) != 1)
		exit_error("Could not parse drive number");

	// check whether 38-bit or 64-bit FileCore is available
	// if yes, use it
	if (!xos_swi_number_from_string("FileCore_SectorOp", NULL))
		read_sectors = readsectors_via_38bit_filecore;
/* commented out as long as I don't know whether ptr to alternative disc record is passed correctly:
	if (!xos_swi_number_from_string("FileCore_DiscOp64", NULL))
		read_sectors = readsectors_via_64bit_filecore;
*/
	// examine disc
	sprintf(disc_spec, ":%d", args.drive_number);
	oslibwrapper(xfilecore_describe_disc(disc_spec, &discrecord, &globals.private_word));
	// display important data:
	// output some data, like sector size and maybe cylinders, heads and sectors
	printf("DEBUG: Disc record says:\n");
	printf("DEBUG:   Sector size:\t\t%d (log2=%d)\n", 1u << discrecord.log2secsize, discrecord.log2secsize);
	printf("DEBUG:   Sectors per track:\t%d\n", discrecord.secspertrack);
	printf("DEBUG:   Heads:\t\t\t%d\n", discrecord.heads);
	printf("DEBUG:   Disc size:\t\t0x%08x %08x (", discrecord.disc_size_hi, discrecord.disc_size);
	print_size((((unsigned long long) discrecord.disc_size_hi) << 32) | discrecord.disc_size);
	printf(")\n");
	printf("DEBUG:   Big_disc flag:\t\t0x%02x\n", discrecord.big_flag);
	printf("DEBUG:   Final padding:\t\t0x%08x\n", ((unsigned int *) &discrecord)[15]);
	// if user asked for it, fake some values
	if (args.force_63_16) {
		discrecord.secspertrack = 63;
		discrecord.heads = 16;
		printf("DEBUG: Faked 63 sectors per track and 16 heads.\n");
	}
	if (args.force_big) {
		discrecord.big_flag = 1;
		printf("DEBUG: Faked \"Big_disc\" flag to 0x01.\n");
	}
	// ("big disc" flag should not make a difference, but check nonetheless!)
}
static void read_boot_block(void)
{
	// Read boot block. Actually it's located at byte offset &0c00, but
	// we're using sector addressing, so we're reading 4096 bytes starting
	// from sector 0 to make sure this works with all sector sizes:
	read_sectors(0, tmp_sector, MAX_SECTOR_SIZE);

// FIXME - add support for PC/BIOS partitioning scheme!
// all this is only for FileCore/ARMLinux partitioning scheme:
	if (tmp_sector[0xdfc] != NONFILECORE_ARMLINUXPARTITIONTABLE)
		exit_error("Second partition is not a linux partition table");

	globals.partition_sector = discrecord.secspertrack * discrecord.heads * ((tmp_sector[0xdfd]) + ((tmp_sector[0xdfe]) << 8));

	// set disc size so FileCore won't refuse to access partition table
	set_sector_limit(globals.partition_sector + 2);	// !PartMan assigns 2 blocks of 512 bytes

	// read partition table
	read_sectors(globals.partition_sector, partitiontable, 1024);
}


// loop over partitions, calling given callback function for each (unless NULL)
// returns whether wanted partition data has been copied to struct (unless NULL)
static bool process_all_partitions(struct linux_part *part, void (*callback)(int id, struct partition *part), struct partition *wanted_part)
{
	struct partition	current;
	bool			found	= FALSE;
	int			partition_id;

	partition_id = 3;	// 1 = FileCore, 2 = Linux partition table
	while ((part->magic == MAGIC_NATIVE) || (part->magic == MAGIC_SWAP)) {
		// convert entry to our own format
		current.start_sector = globals.partition_sector + part->rel_start_sector;	// convert relative to absolute number
		current.sector_count = part->sector_count;
		current.type_string = (part->magic == MAGIC_NATIVE) ? "Native" : "Swap";
		current.is_linux_native = (part->magic == MAGIC_NATIVE);
		// pass to callback
		if (callback)
			callback(partition_id, &current);
		// remember for caller
		if (wanted_part && (partition_id == args.desired_partition)) {
			*wanted_part = current;
			found = TRUE;
		}
		++partition_id;
		++part;
	}
	return found;
}


// display partition info
static void displayinfo(int id, struct partition *part)
{
	static bool	show_header	= TRUE;

	if (show_header) {
		printf(" ID   Start sector    Sectors  Type\n");
		show_header = FALSE;
	}
	printf("%3d    %10d  %10d  %s\n", id, part->start_sector, part->sector_count, part->type_string);
}


// taken from smorbrod lib {
#define BYTES_PER_LINE	16
// dump memory to stream in hex editor format ("00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff : ................\n")
void hexdump(FILE *stream, const byte *buf, size_t len)
{
	char	hex_part[BYTES_PER_LINE * 3 + 1];	// "00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff \0"
	char	ascii_part[BYTES_PER_LINE + 1];		// "................\0"
	int	bytes_now,
		ii;
	byte	b;
	int	offset	= 0;

	while (len) {
		printf("%04x: ", offset);
		bytes_now = len < BYTES_PER_LINE ? len : BYTES_PER_LINE;
		offset += bytes_now;
		for (ii = 0; ii < bytes_now; ii++) {
			b = *buf++;
			sprintf(hex_part + 3 * ii, "%02x ", b);
			ascii_part[ii] = ((b > 31) && (b < 127)) ? b : '.';
		}
		for (/*nothing!*/; ii < BYTES_PER_LINE; ii++) {
			sprintf(hex_part + 3 * ii, "   ");
			ascii_part[ii] = '\0';
		}
		ascii_part[BYTES_PER_LINE] = '\0';
		fprintf(stream, "%s : %s\n", hex_part, ascii_part);
		len -= bytes_now;
	}
}
// }

//
static void main_hexdump_sector(int argc, char *argv[])
{
	unsigned int	sector_number;

	common_start(argc, argv, 3);
	if (sscanf(argv[2], "%d", &sector_number) != 1)
		exit_error("Could not parse sector number");

	read_sectors(sector_number, tmp_sector, 1u << discrecord.log2secsize);
	printf("\nSector %d:\n", sector_number);
	hexdump(stdout, tmp_sector, 1u << discrecord.log2secsize);
}


//
static void main_display_info(int argc, char *argv[])
{
	common_start(argc, argv, 2);
	read_boot_block();
	process_all_partitions((struct linux_part *) partitiontable, displayinfo, NULL);
}


// handle additional arguments (partition number and output filename)
static void get_extended_arguments(char *argv[])
{
	if (sscanf(argv[0], "%d", &args.desired_partition) != 1)
		exit_error("Could not parse partition number");
	args.output_file_name = argv[1];
}


static void done(const char *filedescription)
{
	printf(
"Done.\n"
"If you have IscaFS, double-clicking the %s should open it.\n"
"That is, if the partition contains a valid ext2/ext3 filesystem.\n"
	, filedescription);
}


// file format of pseudo image files
struct pseudo_image_file {
	bits	Phil;		// magic word to recognize file format
	bits	ext2;		// magic word to recognize contents
	int	first_sector;	// first sector of partition
	int	last_sector;	// last sector of partition
	int	log2secsize;	// log2 of sector size
	int	drive;		// drive number
	char	fs[256];	// filing system, nullterminated
};
// generate a pseudo image file
static void main_make_pseudo(int argc, char *argv[])
{
	struct partition		part;
	struct pseudo_image_file	pif;
	int				string_length;

	common_start(argc, argv, 4);
	get_extended_arguments(argv + 2);
	read_boot_block();

	// build pseudo image file in memory
	string_length = strlen(args.filing_system_name) + 1;
	if (string_length > 256)
		exit_error("Length of filing system name looks a bit excessive.");

	if (process_all_partitions((struct linux_part *) partitiontable, NULL, &part) == FALSE)
		return;	// number not found

	if (!part.is_linux_native) {
		fprintf(stderr, "Partition %d is not a Linux Native partition.\n", args.desired_partition);
		return;
	}

	displayinfo(args.desired_partition, &part);

	// fill in the struct
	pif.Phil = 0x4cee68fe;	// "þhîL"       (comment string is UTF-8!)
	pif.ext2 = 0x32747865;	// "ext2"
	pif.first_sector = part.start_sector;
	pif.last_sector = pif.first_sector + part.sector_count - 1;
	pif.log2secsize = discrecord.log2secsize;
	pif.drive = args.drive_number;
	strcpy(pif.fs, args.filing_system_name);

	oslibwrapper(xosfile_save_stamped(
		args.output_file_name,
		FILETYPE_ISCAFS,
		(byte *) &pif,
		((byte *) &pif) + 24 + string_length));	// 24 is length of header before string...

	done("pseudo image file");
}


// dump partition to file
static void main_dump_to_file(int argc, char *argv[])
{
	struct partition	part;
	unsigned int		startsector,
				bytes_per_chunk,
				bytes_to_transfer;
	os_fw			file_handle;
	os_error		*err		= NULL;
	byte			*chunk;
	int			unwritten	= 0;

	common_start(argc, argv, 4);
	get_extended_arguments(argv + 2);
	read_boot_block();

	if (process_all_partitions((struct linux_part *) partitiontable, NULL, &part) == FALSE)
		return;	// not found

	displayinfo(args.desired_partition, &part);

	// check hypothetical size of output file
	if (part.sector_count >= (0xffffffffu >> discrecord.log2secsize))
		exit_error("Dump file would exceed the 4 GB file size limit imposed by RISC OS");

	// calculate transfer values
	startsector = part.start_sector;
	bytes_per_chunk = SECTORS_PER_CHUNK << discrecord.log2secsize;
	bytes_to_transfer = part.sector_count << discrecord.log2secsize;

	// set new disc size so FileCore won't refuse to access partition
	set_sector_limit(startsector + part.sector_count);

	// calculate transfer values: buffer size, transfer count
	chunk = (byte *) malloc(bytes_per_chunk);
	if (chunk == NULL)
		exit_error("Could not allocate transfer buffer");

	// try to create file with needed size
	oslibwrapper(xosfile_create_stamped(
		args.output_file_name,
		part.is_linux_native ? FILETYPE_ISCAFS : FILETYPE_OTHER,
		bytes_to_transfer));

	// open file
	oslibwrapper(xosfind_openupw(
		osfind_NO_PATH | osfind_ERROR_IF_ABSENT | osfind_ERROR_IF_DIR,
		args.output_file_name,
		NULL,
		&file_handle));

	puts("Transfer in progress");

	// transfer loop
	while (bytes_to_transfer > bytes_per_chunk) {
		read_sectors(startsector, chunk, bytes_per_chunk);
		err = xosgbpb_writew(file_handle, chunk, bytes_per_chunk, &unwritten);
		if (err || unwritten)
			break;

		startsector += SECTORS_PER_CHUNK;
		bytes_to_transfer -= bytes_per_chunk;
		putchar('.');
	}
	if ((err == NULL) && (unwritten == 0)) {
		read_sectors(startsector, chunk, bytes_to_transfer);
		err = xosgbpb_writew(file_handle, chunk, bytes_to_transfer, &unwritten);
		putchar('.');
	}

	// close file
	xosfind_closew(file_handle);	// ignore errors

	if (err)
		oslibwrapper(err);
	if (unwritten)
		exit_error("Could not write all bytes");

	//
	if (part.is_linux_native)
		done("image file");
	else
		printf("Done.\n");
}


//
int main(int argc, char *argv[])
{
	int	args_left,
		next_arg;

	// first thing to do, as it's needed by the error handler
	globals.prog_name = argv[0];

	// check number of command line arguments
	if (argc < 2) {
		show_help();
		exit(EXIT_FAILURE);
	}

	args_left = argc - 1;
	next_arg = 1;

	while (args_left--) {
		if (strcmp(argv[next_arg], "-h") == 0) {
			show_help();
			++next_arg;
			continue;
		} else if (strcmp(argv[next_arg], "--help") == 0) {
			show_help();
			++next_arg;
			continue;
		} else if (strcmp(argv[next_arg], OPTION_63_16) == 0) {
			args.force_63_16 = TRUE;
			++next_arg;
			continue;
		} else if (strcmp(argv[next_arg], OPTION_BIG) == 0) {
			args.force_big = TRUE;
			++next_arg;
			continue;
		} else if (strcmp(argv[next_arg], COMMAND_HEX) == 0) {
			main_hexdump_sector(args_left, argv + next_arg + 1);
		} else if (strcmp(argv[next_arg], COMMAND_DISPLAY) == 0) {
			main_display_info(args_left, argv + next_arg + 1);
		} else if (strcmp(argv[next_arg], COMMAND_MKPSEUDO) == 0) {
			main_make_pseudo(args_left, argv + next_arg + 1);
		} else if (strcmp(argv[next_arg], COMMAND_DUMPTOFILE) == 0) {
			main_dump_to_file(args_left, argv + next_arg + 1);
		} else {
			exit_error("Unknown option or command string");
		}
		break;
	}

	return EXIT_SUCCESS;
}
