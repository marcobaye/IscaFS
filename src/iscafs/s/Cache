#multipass on
; Cache (Crache?)
; ~~~~~
; Cache control code and general high-level filesystem interface for read
; operations.
; 23 Mar 2004: 32bitclean


.Cache_CreateCache
FNdt(">>> Cache_CreateCache")
FNdt("  r0 (number of blocks per cache entry) = %0i4")
;------------------------
; Generates a cache tree of the given size.
;------------------------
; On entry:
;	r0  =	number of blocks per cache entry
; On exit:
;	r0  =	pointer to cache control block
;------------------------
	FNfunction("r1-r6")
	mov	r6,r0		; For cachectrl_numentries%
;------------------------
; Claim memory for the cache control block.
	FNmovc(3, len_cachectrl% << config_cachehashbits%)
	bl	Memory_Claim
	FNreturnOnErr
	mov	r0,r2
;------------------------
; Claim memory for the cache entries.
	mov	r4,r6,lsl #shift_cacheent%
	mov	r3,r4,lsl #config_cachehashbits%
	bl	Memory_ClaimZero
	FNreturnOnErr
;------------------------
; Set up and execute loop to fill up cache control blocks.
	mov	r5,#1 << config_cachehashbits%
	mov	r1,r0		; Moving pointer within cache control block.
._lp
	stmia	r1!,{r2,r6}
	add	r2,r2,r4	; Increment pointer to the cache entries.
	subs	r5,r5,#1	; Control blocks counter.
	bgt	_lp
FNdt("<<< Cache_CreateCache")
FNdt("  r0 (pointer to cache control block) = %0x8")
	FNreturnClean


.Cache_Initialise
FNdt(">>> Cache_Initialise")
;------------------------
; Initialises all the cache information.
;------------------------
; On entry:
;	Nothing required
; On exit:
;	ARP
;------------------------
	FNfunction("r0-r4")
;------------------------
; Set up the A and B cache control blocks.
	mov	r0,#config_blocksA%
	bl	Cache_CreateCache
	strvc	r0,[r12,#blocktableA]
	movvc	r0,#config_blocksB%
	blvc	Cache_CreateCache
	strvc	r0,[r12,#blocktableB]
FNdt("<<< Cache_Initialise")
	FNreturnAsIs


.Cache_FindBlockInCache
FNdt(">>> Cache_FindBlockInCache")
FNdt("  r0 (block number) = %0i4")
FNdt("  r1 (hash value) = %1x8")
FNdt("  r2 (cache control blocks ptr) = %2x8")
FNdt("  r6 (MDB) = %6x8")
;------------------------
; Tries to find the given block in the cache specified.
;------------------------
; Get a numbered block from disc
; On entry:
;	r0  =	block number
;	r1  =	hash value
;	r2  =	pointer to start of cache control blocks to search
;	r6  =	pointer to MDB
; On exit:
;	r2  =	pointer to cache entry, or zero if block wasn't found
;------------------------
	FNfunction("r0,r1,r3-r11")
	add	r2,r2,r1,lsl #shift_cachectrl%
; now uses one LDMIA instead of two LDRs
; old:
;	ldr	r3,[r2,#cachectrl_numentries%]
;	ldr	r2,[r2,#cachectrl_pointer%]
; new:
	ldmia	r2,{r2,r3}

; FNdt("iii Checking in cache control block %2x8")
	ldr	r14,[r6,#mnt_volume_id%]
._lp
	ldr	r1,[r2,#cacheent_blocknum%]
	ldr	r4,[r2,#cacheent_vol_id%]
; FNdt("iii Checking entry %1x8, %4x8 (%0x8, %6x8), r3 = %3i4")
	teq	r0,r1		; Same block number?
; this was buggy. After umounting/mounting, same MDB could
; mean different volume. Now checks (unique!) volume id instead of MDB.
; old:
;	teqeq	r6,r4		; Same mount descriptor block?
; new:
	teqeq	r14,r4		; Same volume id?

FNdtc(eq, "<<< Cache_FindBlockInCache (succeeded)")
FNdtc(eq, "  r2 (cache entry) = %2x8")
	BEQ	_clean_exit	; changed creturn to BEQ
	add	r2,r2,#len_cacheent%
	subs	r3,r3,#1
	bgt	_lp
	mov	r2,#0		; No matching block was found.
FNdt("<<< Cache_FindBlockInCache (failed)")
FNdt("  r2 (cache entry) = %2x8")
._clean_exit
	FNreturnClean


.Cache_CleanBlock
FNdt(">>> Cache_CleanBlock")
FNdt("  r0 (block number) = %0i4")
FNdt("  r4 (block table entry) = %4x8")
FNdt("  r6 (MDB) = %6x8")
;------------------------
; Writes the block's data back into the filesystem from whence it came.
;------------------------
; On entry:
;	r0  =	block number
;	r4  =	pointer to block table entry
;	r6  =	pointer to MDB
; On exit:
;	All registers preserved.
;------------------------
;FNdt("<<< Cache_CleanBlock")
	B	IE_Error_ReadOnly


.Cache_GetBlock
FNdt(">>> Cache_GetBlock")
FNdt("  r0 (block number) = %0i4")
FNdt("  r6 (MDB) = %6x8")
;------------------------
; Tries to find a block in the cache; if it fails it reads the requested block
; into the next available slot.
;------------------------
; Get a numbered block from disc
; On entry:
;	r0  =	block number
;	r6  =	pointer to MDB
; On exit:
;	r0  =	pointer to block
;	r1  =	pointer to block table entry
;------------------------
	FNfunction("r2-r11")
;------------------------
; Generate the hash value for the given block.
	eor	r1,r0,r0,lsr #13
	eor	r1,r1,r6,lsr #2
	and	r1,r1,#cache_hashmask%
;------------------------
; Search for the block in each cache.
	ldr	r2,[r12,#blocktableB]
	bl	Cache_FindBlockInCache
	teq	r2,#0
	bne	_found_cache_entry
	ldr	r2,[r12,#blocktableA]
	bl	Cache_FindBlockInCache
	teq	r2,#0
	beq	_cache_miss
;------------------------
; Find a block in cache B which we can promote our cache A block into.
	ldr	r3,[r12,#blocktableB]
	add	r3,r3,r1,lsl #shift_cachectrl%
	ldr	r3,[r3,#cachectrl_pointer%]
	FNrnd(4)
	and	r4,r4,#config_blocksB%-1
	add	r3,r3,r4,lsl #shift_cacheent%
;------------------------
; Switch the two, demoting the block from B, and promoting that from A.
	ldmia	r2,{r4,r5,r7,r8}
	ldmia	r3,{r9,r10,r11,r14}
	stmia	r3,{r4,r5,r7,r8}
	stmia	r2,{r9,r10,r11,r14}
	mov	r2,r3		; The required block has moved to here.
; commented out because fall-through works as well
;	b	_found_cache_entry

; FALLTHROUGH

._found_cache_entry
;------------------------
; We've found the entry - its cacheent is in r2.
	mov	r1,r2
	ldr	r0,[r2,#cacheent_pointer%]
FNdt("<<< Cache_GetBlock")
FNdt("  r0 (block pointer) = %0x8")
FNdt("  r1 (cache entry) = %1x8")
	FNreturnClean

._cache_miss
;------------------------
; Find a block in cache A we can load the data into.
; fixed wrong cache references.
;	ldr	r3,[r12,#blocktableB]
	ldr	r3,[r12,#blocktableA]
	add	r3,r3,r1,lsl #shift_cachectrl%
	ldr	r3,[r3,#cachectrl_pointer%]
	FNrnd(4)
;	and	r4,r4,#config_blocksB%-1
	and	r4,r4,#config_blocksA%-1
	add	r4,r3,r4,lsl #shift_cacheent%

;------------------------
; If there's no block currently there, claim one.
	ldr	r2,[r4,#cacheent_pointer%]
	ldr	r8,[r6,#s_log_block_size%]
	mov	r3,#1024	; Get block size in bytes.
	mov	r3,r3,lsl r8
	teq	r2,#0
	beq	_claim_target_block
;------------------------
; If there's an existing block which is the right size, use that.
	ldr	r1,[r4,#cacheent_flags%]
	tst	r1,#fcacheent_dirty%
	blne	Cache_CleanBlock
	and	r1,r1,#fcacheent_blksize%
	cmp	r1,r8		; Compare against filesystem's block size.
	beq	_existing_block_ok
; BLLT/MOVLT combo wasn't 32bit-safe. Added BGE before.
	bge	_claim_target_block
	bl	Memory_Free	; Free old block (wrong size).
	mov	r2,#0
._claim_target_block
	bl	Memory_Resize	; Claim new block (right size!).
	FNreturnOnErr		; !!! Handle this more gracefully.
	str	r2,[r4,#cacheent_pointer%]
._existing_block_ok
;------------------------
; Store all pertinent information about this block.
	movs	r7,r0		; Put block number into a stmable register.
				; set flags here - EQ implies hole
; changed to fix MDB problem. Now uses unique volume id.
; old:
;	stmib	r4,{r6-r8}	; Mount, block num, flags (block size).
; new:
	ldr	r5,[r6,#mnt_volume_id%]	; get unique volume id
	stmib	r4,{r5,r7,r8}	; vol id, block num, flags (block size).

;------------------------
; Store all pertinent information about this block.
	mov	r1,r4		; Return value - pointer to cache entry.
	mov	r0,r2		; Return value - pointer to block data.
	beq	_read_from_hole
	add	r8,r8,#10	; Shift for block num -> file offset.
FNdt("  r7 () = %7x8")
	mov	r4,r7,lsl r8	; Get file offset (low) from block number.
	rsb	r14,r8,#32
	mov	r5,r7,lsr r14	; Get file offset (high) from block number.
FNdt("  r5 (high) = %5x8")
FNdt("  r4 (low)  = %4x8")
	mov	r14,pc
	ldr	pc,[r6,#mnt_readbytes%]
FNdt("<<< Cache_GetBlock")
FNdt("  r0 (block pointer) = %0x8")
FNdt("  r1 (cache entry) = %1x8")
	FNreturnClean

._read_from_hole
;------------------------
; Read bytes from a black hole.
;------------------------
; On entry:
;	r2  =	pointer to buffer
;	r3  =	number of bytes to read
;	r4  =	partition offset
;	r6  =	pointer to mount descriptor block
; On exit:
;	r3  =	number of bytes not read
;------------------------
	mov	r1,r2
	mov	r2,r3
	bl	Memory_ZeroBlock
FNdt("<<< Cache_GetBlock (hole)")
FNdt("  r0 (block pointer) = %0x8")
FNdt("  r1 (cache entry) = %1x8")
	FNreturnClean


.Cache_FindInode
FNdt(">>> Cache_FindInode")
FNdt("  r0 (pathname) = %0z")
FNdt("  r6 (MDB) = %6x8")
;------------------------
; Returns the inode number of the item described by the given pathname.
;------------------------
; On entry:
;	r0  =	pointer to full pathname
;	r6  =	pointer to MDB
; On exit:
;	r0  =	inode number (0 if not found)
;	r1  =	filetype
;------------------------
	FNfunction("r2-r11")
	ADDS	r5,r0,#0		; clears V
	mov	r0,#2
	ldrneb	r1,[r5]
	teqne	r1,#0
FNdtc(eq, "<<< Cache_FindInode (root)")
FNdtc(eq, "  r0 (inode number) = %0i4")
FNdtc(eq, "  r1 (filetype) = %1x8")
	FNpcreturn("EQ")		; is ok because V is clear
	MOV	r2,#2			; inode number of root
._dir_loop
	MOV	r4,#0			; length of string
	MOV	r11,r5
._lp
	LDRB	r14,[r11],#1		; get length of current leafname
	TEQ	r14,#0
	TEQNE	r14,#ASC"."
	ADDNE	r4,r4,#1
	BNE	_lp
	MOV	r0,r2
	MOV	r1,#0
	MOV	r2,#0			; inode number of found inode
	ADR	r11,_match_leaf
	BL	Directory_Scan
FNdtc(vs, "<<! Cache_FindInode (Directory_Scan failed)")
	FNreturnOnErr
	MOV	r1,r3			; filetype
	TEQ	r2,#0
	BEQ	_not_found
	ADD	r5,r5,r4		; move to next leafname
	LDRB	r10,[r5],#1		; directory separator or 0-terminator
	TEQ	r10,#0			; more subentries?
	BNE	_dir_loop		; yes
._not_found
	MOV	r0,r2			; nope
; Not finding an object is not always an error. Caller must decide.
FNdt("<<< Cache_FindInode")
FNdt("  r0 (block pointer) = %0x8")
FNdt("  r1 (cache entry) = %1x8")
	FNreturnClean

._match_leaf
FNdt("_match_leaf")
;------------------------
; Code segment for use with Directory_Scan which checks if the name of the item
; given matches the requested name.  Exits immediately if match is found.
;------------------------
; On entry:
;	r0  =	pointer to dirent structure
;	r4  =	length of leafname to find
;	r5  =	pointer to leafname
; On exit:
;	r0  =	-1 if matched, unchanged if didn't
;	r2  =	inode number if matched, unchanged if didn't
;	r3  =	filetype of file (if r0=-1)
;------------------------
	FNfunction("r1,r4-r7")
	LDR	r1,[r0,#dirent_entry_length%]
	ADD	r6,r0,#dirent_name%
	MOV	r1,r1,LSR #16
	AND	r1,r1,#255		; needed if FS uses "filetype-in-dir" feature
; Fixed a strange bug:
; The length of an ext2 filename is given in the dirent; the entry is *NOT*
; nullterminated. Imagine an old and unused direntry called "abcdefghijkl". A
; new file called "zyx" is then saved to this entry, resulting in
; "zyxdefghijkl". If IscaFS 0.08 then happened to search for anything from
; "zyx" to "zyxdefghijkl", it always returned this entry as a match. =8-|
; I only noticed because there was a *real* entry with the wanted name
; later on in the directory, and IscaFS kept accessing the first.
; Checking the flags after calculating the length of the hypothetical
; "comma-postfix" should fix it:
	SUBS	r7,r1,r4
	BMI	_clean_exit		; changed creturn to BMI
	TEQNE	r7,#4			; ext2 name must have same
	BNE	_clean_exit		; length or be 4 (",xxx") chars longer
	MOV	r7,r4			; save local filename length in r7
; FIXME - does this mean that NAME+4CHARS is always accepted?!
._lp
		LDRB	r3,[r6],#1	; FIXME - convert invalid chars!
		LDRB	r14,[r5],#1
		TEQ	r3,#ASC"."
		MOVEQ	r3,#ASC"/"
		TEQ	r3,#ASC" "	; check for SPACE
		MOVEQ	r3,#&a0		; and replace with ALT-SPACE
		TEQ	r3,r14
		BNE	_clean_exit	; has been creturn
		SUBS	r4,r4,#1
		BGT	_lp
	MOV	r5,r0			; save dirent pointer in r5
	ADD	r0,r0,#dirent_name%
	; r0 => ext2 filename
	; r1 = ext2 filename length
	BL	File_FiletypeFromLeafname	; never fails
	MOV	r3,r0			; r3 = filetype
	MOV	r0,r5			; restore dirent pointer
	TEQ	r1,r7			; do lengths match without ",xxx"?
	LDREQ	r2,[r0,#dirent_inode%]
	MVNEQ	r0,#0			; "-1" = matched
._clean_exit
	FNreturnClean


.Cache_GetInodePointer
FNdt(">>> Cache_GetInodePointer")
FNdt("  r0 (inode number) = %0i4")
FNdt("  r6 (MDB) = %6x8")
;------------------------
; Given the inode number, returns a pointer to the inode descriptor.  Block
; locking has been removed, and instead the inode contents will be copied into
; the global temporary workspace in case it is flushed from the buffers.
;------------------------
; On entry:
;	r0  =	inode number
;	r6  =	pointer to MDB
; On exit:
;	r0  =	pointer to inode structure
;------------------------
	FNfunction("r1-r4")
	SUB	r0,r0,#1		; inodes are numbered from 1 - b'zarre
	LDR	r3,[r6,#s_inodes_per_group%]
	MOV	r2,r0
	BL	Divide			; r0 = r2/r3 ; r2 = r2%r3
	FNreturnOnErr
; group descriptors contain *absolute* block numbers!
	LDR	r14,[r6,#mnt_groupdescs%]
	ADD	r0,r14,r0,LSL #shift_groupdesc%
	LDR	r0,[r0,#bg_inode_table%]; block number of inode table start

	LDR	r1,[r6,#s_log_block_size%]
	MOV	r14, #1			; StrongARM order
	ADD	r1, r1, #3
	ADD	r0, r0, r2, LSR r1
	MOV	r14, r14, LSL r1
	SUB	r14, r14, #1
	AND	r2, r2, r14
	BL	Cache_GetBlock		; removed useless VC condition
	STRVC	r0,[r6,#mnt_inodeblockaddr%]
	STRVC	r1,[r6,#mnt_inodetabaddr%]
	ADDVC	r0,r0,r2,LSL #7		; inode offset in block
FNdt("<<< Cache_GetInodePointer")
FNdt("  r0 (inode structure) = %0x8")
	FNreturnAsIs


.Cache_BlockFromInode
FNdt(">>> Cache_BlockFromInode")
FNdt("  r0 (block number) = %0i4")
FNdt("  r1 (inode definition) = %1x8")
FNdt("  r6 (MDB) = %6x8")
;------------------------
; Returns a pointer to the nth block of an inode.
;------------------------
; On entry:
;	r0  =	block number
;	r1  =	pointer to inode definition
;	r6  =	pointer to MDB
; On exit:
;	r0  =	pointer to block (-1 = no such block, outside file)
;	r1  =	pointer to end of block
;	r2  =	pointer to block table entry
;------------------------
	FNfunction("r3")
	LDR	r2,[r6,#s_log_block_size%]
	MOV	r3,#1024
	MOV	r3,r3,LSL r2
	BL	Cache_BlockNumberFromInode
FNdtc(vs, "<<! Cache_BlockFromInode (Cache_BlockNumberFromInode failed)")
	FNreturnOnErr
; negative block pointers are okay now
; new:
	CMN	r0, #1			; check for -1 (illegal)
	BEQ	_clean_exit
; old:
;	CMP	r0,#0
;FNdtc(lt, "<<? Cache_BlockFromInode (negative block pointer)")
;	BLT	_clean_exit		; changed creturn to BLT

	BL	Cache_GetBlock
	MOV	r2,r1
	ADD	r1,r0,r3
FNdt("<<< Cache_BlockFromInode")
FNdt("  r0 (pointer to block) = %0x8")
FNdt("  r1 (pointer to end of block) = %1x8")
FNdt("  r2 (block table entry) = %2x8")
._clean_exit
	FNreturnClean


.Cache_BlockNumberFromInode
FNdt(">>> Cache_BlockNumberFromInode")
FNdt("  r0 (block number) = %0i4")
FNdt("  r1 (inode definition ptr) = %1x8")
FNdt("  r6 (MDB) = %6x8")
;------------------------
; Gets the block number of an inode's nth block.
;------------------------
; On entry:
;	r0  =	block number
;	r1  =	pointer to inode definition
;	r6  =	pointer to MDB
; On exit:
;	r0  =	block number (-1 = no such block, outside file)
;------------------------
	FNfunction("r1-r4,r8")
; fixed i_512bblocks% usage. i_512bblocks% contains the number of allocated
; blocks in traditional UNIX fashion - that is, in 512-byte blocks, regardless
; of the file system's logical block size.
; In addition to that, the i_512bblocks% count does not include black holes.
; So now the file extent is used instead to check for "outside file".
; new:
	LDR	r2,[r6,#s_log_block_size%]	; r2 = log2-10
	LDR	r3,[r1,#i_size%]		; r3 = file extent
	ADD	r2,r2,#10			; r2 = log2
	CMP	r3,r0,LSL r2			; cmp extent,wantedoffset
	BLS	_no_such_block
	ADD	r1,r1,#i_block%
	SUB	r8,r2,#2			; r8 = block pointers per block
; old:
;	ldr	r2,[r1,#i_blocks%]
;	cmp	r0,r2,LSR #1	; for some odd reason it's 2x too big
;	bge	_no_such_block
;	ldr	r2,[r6,#s_log_block_size%]
;	add	r1,r1,#i_block%
;	add	r8, r2, #8	; 8=10-2 (10 add to s_log, 2 for 1word/entry)

	subs	r4,r0,#12		; main section?
	bge	_sub_block
	ldr	r0,[r1,r0,LSL #2]; get block number
FNdt("<<< Cache_BlockNumberFromInode (primary block)")
FNdt("  r0 (block number) = %0i4")
	FNreturnClean

._sub_block
	MOV	r3,#1
	MOV	r3,r3,LSL r8		; number of words in one block
	SUBS	r2,r4,r3		; this level ok?
	BGE	_sub_sub_block
	LDR	r0,[r1,#12*4]		; get 13th block number
	BL	Cache_GetBlock
	LDRVC	r0,[r0,r4,LSL #2]
FNdt("<<< Cache_BlockNumberFromInode (indirected block)")
FNdt("  r0 (block number) = %0i4")
	FNreturnAsIs

._sub_sub_block
	MOV	r3,r3,LSL r8
	SUBS	r4,r2,r3		; this level ok?
	BGE	_sub_sub_sub_block
	LDR	r0,[r1,#13*4]		; get 14th block number
	BL	Cache_GetBlock
	MOVVC	r4,r2,LSR r8		; get next parent block
	LDRVC	r0,[r0,r4,LSL #2]
	BLVC	Cache_GetBlock
	SUBVC	r2,r2,r4,LSL r8
	LDRVC	r0,[r0,r2,LSL #2]
FNdt("<<< Cache_BlockNumberFromInode (doubly indirected block)")
FNdt("  r0 (block number) = %0i4")
	FNreturnAsIs

._sub_sub_sub_block
	LDR	r0,[r1,#14*4]		; get 15th block number
	BL	Cache_GetBlock
	MOVVC	r3,r8,LSL #1
	MOVVC	r2,r4,LSR r3
	LDRVC	r0,[r0,r2,LSL #2]
	SUBVC	r4,r4,r2,LSL r3
	BLVC	Cache_GetBlock
	MOVVC	r2,r4,LSR r8		; get next parent block
	LDRVC	r0,[r0,r2,LSL #2]
	BLVC	Cache_GetBlock
	SUBVC	r4,r4,r2,LSL r8
	LDRVC	r0,[r0,r4,LSL #2]
FNdt("<<< Cache_BlockNumberFromInode (triply indirected block)")
FNdt("  r0 (block number) = %0i4")
	FNreturnAsIs

._no_such_block
FNdt("<<? Cache_BlockNumberFromInode (unknown block)")
FNdt("  r0 (block number) = %0i4 (returning -1)")
	MVN	r0,#0			; return -1 (no more blocks)
	FNreturnClean
