REM File containing internal workspace definitions



REM Main workspace - zeroed at module initialisation
PROCwksp_init
heap		= FNwksp_int
blocktableA	= FNwksp_int
blocktableB	= FNwksp_int
random_seed	= FNwksp_int
firstmount	= FNwksp_int:REM FIXME - check whether used correctly
firstfile	= FNwksp_int
ptr_blockbuffer	= FNwksp_int:REM renamed from "buffer"
ptr_inodebuffer	= FNwksp_int:REM renamed from "buffer2"
sysflags	= FNwksp_int:REM renamed from "debug"
	REM added flag to keep from deregistering twice
	sysflag_ifs_registered%	= 1:REM if set, de-register IFS on exit
	REM removed "sysflag_oldfilecore%" flag
filetypebuffer	= FNwksp_add(1,12):REM needed for conversions
len_filetypebuf	= 11:REM maximum length of ".ext" extension
REM deb2		= FNwksp_int	commented out
read_part_fn	= FNwksp_int:REM ReadPartition function ptr
disc_size_limit	= FNwksp_int:REM number of bits (!) - FIXME, rename to log2 or something
last_volume_id	= FNwksp_int:REM added to solve caching bug
len_workspace%	= FNwksp_length
IF debug% THEN
DebugHandle%	= FNwksp_int
DebugIndent%	= FNwksp_int
DebugFlags%	= FNwksp_int
len_workspace%	= FNwksp_length
ENDIF

REM The MAlloc vectors are added after the main workspace is stored, so
REM len_workspace% is NOT the real length which will be allocated to the
REM workspace.
IF config_dynamicareas% THEN
	malloc_tabbase%		= FNwksp_length
	malloc_claim%		= FNwksp_int
	malloc_free%		= FNwksp_int
	malloc_resize%		= FNwksp_int
	malloc_getblocksize%	= FNwksp_int
	malloc_enumerateblocks%	= FNwksp_int
	malloc_blockcopy%	= FNwksp_int
	malloc_shiftblock%	= FNwksp_int
ENDIF


len_blockbuffer%	= 4096		:REM maximum size of a block
len_inodebuffer%	= 128		:REM size of an inode



REM Cache control block
PROCwksp_init
cachectrl_pointer%	= FNwksp_int
cachectrl_numentries%	= FNwksp_int

len_cachectrl%		= FNwksp_length
shift_cachectrl%	= 3



REM Cache entry block
PROCwksp_init
cacheent_pointer%	= FNwksp_int	:REM 0 if no block claimed for it.
cacheent_vol_id%	= FNwksp_int	:REM 0 if the cache entry is invalid. (used to be called "cacheent_mount%")
cacheent_blocknum%	= FNwksp_int
cacheent_flags%		= FNwksp_int

len_cacheent%		= FNwksp_length
shift_cacheent%		= 4



REM Flags for cacheent_flags% in cache entry for a single block
fcacheent_blksize%	= 3		:REM log-2 block size in kilobytes.
fcacheent_dirty%	= 4



REM Mount descriptor structure
PROCwksp_init
next%			= FNwksp_int
last%			= FNwksp_int
mnt_flags%		= FNwksp_int
mnt_filehandle%		= FNwksp_int
mnt_startsector%	= FNwksp_int
mnt_endsector%		= FNwksp_int
mnt_lbtsectorlen%	= FNwksp_int	:REM log to the base 2 of sector length
mnt_drivenumber%	= FNwksp_int
mnt_instanceword%	= FNwksp_int
mnt_descriptor%		= FNwksp_int
mnt_readbytes%		= FNwksp_int	:REM read/write function vectors
mnt_writebytes%		= FNwksp_int
mnt_inodeblockaddr%	= FNwksp_int
mnt_inodetabaddr%	= FNwksp_int
mnt_numgroups%		= FNwksp_int
mnt_groupdescs%		= FNwksp_int
mnt_volume_id%		= FNwksp_int

REM superblock structure (inside image descriptor structure)
superblock%		= FNwksp_length
s_inodes_count%		= FNwksp_int
s_blocks_count%		= FNwksp_int
s_r_blocks_count%	= FNwksp_int:REM number of reserved blocks (for super-user)
s_free_blocks_count%	= FNwksp_int
s_free_inodes_count%	= FNwksp_int
s_first_data_block%	= FNwksp_int:REM 1 for 1K block size, 0 for all others
s_log_block_size%	= FNwksp_int:REM 0/1/2 for 1K/2K/4K (i.e. add 10 to get log2)
s_log_frag_size%	= FNwksp_int:REM in ext4 now log_cluster_size (bigalloc feature)
s_blocks_per_group%	= FNwksp_int:REM 8K/16K/32K for 1K/2K/4K block size
s_frags_per_group%	= FNwksp_int:REM in ext4 now clusters_per_group (bigalloc feature)
s_inodes_per_group%	= FNwksp_int
s_mtime%		= FNwksp_int:REM mount time
s_wtime%		= FNwksp_int:REM write time
s_mnt_count%		= FNwksp_short:REM mounts since last fsck
s_max_mnt_count%	= FNwksp_short:REM when fsck is forced
s_magic%		= FNwksp_short:REM must be 0xef53
s_state%		= FNwksp_short
s_errors%		= FNwksp_short:REM do what? continue, remount readonly, panic?
s_minor_rev_level%	= FNwksp_short
s_lastcheck%		= FNwksp_int:REM date of last fsck
s_checkinterval%	= FNwksp_int:REM max time between fsck
s_creator_os%		= FNwksp_int
s_rev_level%		= FNwksp_int:REM 0 or 1, see below
s_def_resuid%		= FNwksp_short:REM default uid for reserved blocks
s_def_resgid%		= FNwksp_short:REM default gid for reserved blocks
REM rev level 0 stops here, rev level 1 goes on:
s_first_ino%		= FNwksp_int:REM first non-reserved inode
s_inode_size%		= FNwksp_short:REM default was 128, ext4 changed to 256
s_block_group_nr%	= FNwksp_short:REM where this superblock is
s_feature_compat%	= FNwksp_int:REM compatible features
s_feature_incompat%	= FNwksp_int:REM incompatible features
s_feature_ro_compat%	= FNwksp_int:REM readonly-compatible features
s_uuid%			= FNwksp_add(4,4)
s_volume_name%		= FNwksp_add(1,16)
s_last_mounted%		= FNwksp_int
REM end of superblock structure (actually it goes on, but we don't care)
REM Note: len_superblock% is not the actual length of a superblock, but the
REM length of it that should be read into the block.
len_superblock%		= FNwksp_length - superblock%
len_mount%		= FNwksp_length



REM FileCore descriptor block
PROCwksp_init
desc_log2secsize%	= FNwksp_byte
desc_secspertrack%	= FNwksp_byte
desc_heads%		= FNwksp_byte
desc_density%		= FNwksp_byte
desc_idlen%		= FNwksp_byte
desc_log2bpmp%		= FNwksp_byte
desc_skew%		= FNwksp_byte
desc_bootoption%	= FNwksp_byte
desc_lowsector%		= FNwksp_byte
desc_nzones%		= FNwksp_byte
desc_zone_spare%	= FNwksp_add(1,4)	:REM unaligned int
desc_root%		= FNwksp_short
desc_disc_size%		= FNwksp_int
desc_disc_id%		= FNwksp_short
desc_disc_name%		= FNwksp_add(1,10)
desc_disctype%		= FNwksp_int
REM following fields are used in RiscOS 3.6 and later
desc_disc_size2%	= FNwksp_int
desc_share_size%	= FNwksp_byte
desc_big_flag%		= FNwksp_byte
desc_reserved%		= FNwksp_current

len_desc%		= 64


REM image flags
mntflag_partition%	= 1
mntflag_writeable%	= 1<<1
mntflag_synchronous%	= 1<<2		:REM synchronous writes are wanted


REM directory entry structure
PROCwksp_init
dirent_inode%		= FNwksp_int
dirent_entry_length%	= FNwksp_short	:REM always loaded as a word,
dirent_name_length%	= FNwksp_short	:REM so you won't find "_name_"
dirent_name%		= FNwksp_current

len_dirent%		= FNwksp_length	:REM Note - only base length



n_dir_blocks%		= 12

REM inode structure
PROCwksp_init
i_mode%			= FNwksp_short
i_uid%			= FNwksp_short
i_size%			= FNwksp_int
i_atime%		= FNwksp_int
i_ctime%		= FNwksp_int
i_mtime%		= FNwksp_int
i_dtime%		= FNwksp_int
i_gid%			= FNwksp_short
i_links_count%		= FNwksp_short
i_512bblocks%		= FNwksp_int:REM has been i_blocks%
i_flags%		= FNwksp_int
i_reserved1%		= FNwksp_int
i_block%		= FNwksp_add(4,15):REM Pointers to blocks
i_version%		= FNwksp_int
i_file_acl%		= FNwksp_int
i_dir_acl%		= FNwksp_int
i_faddr%		= FNwksp_int
i_frag%			= FNwksp_byte
i_fsize%		= FNwksp_byte
i_loadexecflag%		= FNwksp_current
i_pad1%			= FNwksp_short
i_loadaddr%		= FNwksp_current
i_reserved2_1%		= FNwksp_int
i_execaddr%		= FNwksp_current
i_reserved2_2%		= FNwksp_int

len_inode%		= FNwksp_length

REM Open file descriptor block
REM Note - everything before file_next% is the inode block.  Inode number
REM (file_inode%) is kept for future write-ability to enable inode information
REM to be written back to the filesystem.
file_next%		= FNwksp_int
file_last%		= FNwksp_int
file_inode%		= FNwksp_int
file_type%		= FNwksp_int
file_mount%		= FNwksp_int

len_file%		= FNwksp_length



REM flags used in i_mode%
i_type_fifo%		= &1000
i_type_chardev%		= &2000
i_type_directory%	= &4000	:REM plain old directory
i_type_blkdev%		= &6000
i_type_regular%		= &8000	:REM plain old file
i_type_symlink%		= &a000
i_type_socket%		= &c000
i_type_wht%		= &e000	:REM what's this?
i_mode_typemask%	= &f000



REM group descriptor structure
PROCwksp_init
bg_block_bitmap%	= FNwksp_int
bg_inode_bitmap%	= FNwksp_int
bg_inode_table%		= FNwksp_int
bg_free_blocks_count%	= FNwksp_short	:REM FIXME - code still assumes int!
bg_free_inodes_count%	= FNwksp_short	:REM FIXME - code still assumes int!
bg_used_dirs_count%	= FNwksp_short	:REM FIXME - code still assumes int!
bg_pad%			= FNwksp_short
bg_reserved1%		= FNwksp_int
bg_reserved2%		= FNwksp_int
bg_reserved3%		= FNwksp_int

len_groupdesc%		= FNwksp_length
REM ensure length is really 32,
REM so a simple shift can be used for converting name to offset
IF len_groupdesc% <> 32 THEN PRINT "Group descriptor struct has wrong length!":ERROR 0,"Group descriptor struct has wrong length!"

shift_groupdesc%	= 5
